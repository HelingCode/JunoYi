# JunoYi 模块开发指南

本文档详细说明如何在 JunoYi 框架基础上进行二次开发，包括如何创建新模块、模块间如何引用关联。

---

## 一、快速开始 - 创建新模块

假设我们要创建一个**商品管理模块 (Product)**，需要以下步骤：

### 步骤 1: 创建 API 模块

在 `junoyi-module-api` 目录下创建新模块：

```bash
cd junoyi-module-api
mkdir junoyi-module-product-api
```

#### 1.1 创建 pom.xml

`junoyi-module-api/junoyi-module-product-api/pom.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <!-- 继承父模块 -->
    <parent>
        <groupId>cn.junoyi</groupId>
        <artifactId>junoyi-module-api</artifactId>
        <version>${revision}</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>junoyi-module-product-api</artifactId>
    <description>商品管理模块API</description>

    <dependencies>
        <!-- 依赖公共模块 -->
        <dependency>
            <groupId>cn.junoyi</groupId>
            <artifactId>junoyi-common</artifactId>
        </dependency>

        <!-- MyBatis Plus (用于 Mapper 和 Entity) -->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <scope>provided</scope>
        </dependency>
    </dependencies>
</project>
```

#### 1.2 创建目录结构

```
junoyi-module-product-api/
└── src/main/java/cn/junoyi/module/product/api/
    ├── domain/
    │   ├── entity/         # 实体类
    │   │   └── Product.java
    │   ├── vo/             # 视图对象
    │   │   └── ProductVO.java
    │   └── bo/             # 业务对象
    │       └── ProductBO.java
    ├── service/            # 服务接口
    │   └── IProductService.java
    └── mapper/             # Mapper接口
        └── ProductMapper.java
```

#### 1.3 创建实体类示例

`Product.java`

```java
package cn.junoyi.module.product.api.domain.entity;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@TableName("product")
public class Product {
    
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String name;
    
    private String description;
    
    private BigDecimal price;
    
    private Integer stock;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
    
    @TableLogic
    private Integer deleted;
}
```

#### 1.4 创建 VO 示例

`ProductVO.java`

```java
package cn.junoyi.module.product.api.domain.vo;

import lombok.Data;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
public class ProductVO {
    private Long id;
    private String name;
    private String description;
    private BigDecimal price;
    private Integer stock;
    private LocalDateTime createTime;
}
```

#### 1.5 创建 Mapper 接口

`ProductMapper.java`

```java
package cn.junoyi.module.product.api.mapper;

import cn.junoyi.module.product.api.domain.entity.Product;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface ProductMapper extends BaseMapper<Product> {
    // 继承 BaseMapper 即可使用基础 CRUD 方法
    // 可以在这里添加自定义查询方法
}
```

#### 1.6 创建 Service 接口

`IProductService.java`

```java
package cn.junoyi.module.product.api.service;

import cn.junoyi.module.product.api.domain.entity.Product;
import cn.junoyi.module.product.api.domain.vo.ProductVO;
import com.baomidou.mybatisplus.extension.service.IService;
import java.util.List;

public interface IProductService extends IService<Product> {
    
    /**
     * 获取商品列表
     */
    List<ProductVO> getProductList();
    
    /**
     * 根据ID获取商品详情
     */
    ProductVO getProductById(Long id);
    
    /**
     * 创建商品
     */
    boolean createProduct(Product product);
}
```

---

### 步骤 2: 在父模块中注册 API 模块

修改 `junoyi-module-api/pom.xml`，添加新模块：

```xml
<modules>
    <module>junoyi-module-system-api</module>
    <module>junoyi-module-product-api</module>  <!-- 新增 -->
</modules>
```

---

### 步骤 3: 在 dependencies 模块中注册版本

修改 `junoyi-dependencies/pom.xml`，添加新模块的版本管理：

```xml
<dependencyManagement>
    <dependencies>
        <!-- 其他依赖... -->
        
        <!-- 新增商品模块API -->
        <dependency>
            <groupId>cn.junoyi</groupId>
            <artifactId>junoyi-module-product-api</artifactId>
            <version>${revision}</version>
        </dependency>
    </dependencies>
</dependencyManagement>
```

---

### 步骤 4: 创建实现模块

在 `junoyi-module` 目录下创建实现模块：

```bash
cd junoyi-module
mkdir junoyi-module-product
```

#### 4.1 创建 pom.xml

`junoyi-module/junoyi-module-product/pom.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>cn.junoyi</groupId>
        <artifactId>junoyi-module</artifactId>
        <version>${revision}</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>junoyi-module-product</artifactId>
    <description>商品管理模块实现</description>

    <dependencies>
        <!-- 依赖对应的 API 模块 -->
        <dependency>
            <groupId>cn.junoyi</groupId>
            <artifactId>junoyi-module-product-api</artifactId>
        </dependency>

        <!-- 依赖框架核心 -->
        <dependency>
            <groupId>cn.junoyi</groupId>
            <artifactId>junoyi-framework-web</artifactId>
        </dependency>

        <!-- 依赖公共模块 -->
        <dependency>
            <groupId>cn.junoyi</groupId>
            <artifactId>junoyi-common</artifactId>
        </dependency>

        <!-- Spring Boot Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- MapStruct (对象转换) -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct-processor</artifactId>
            <scope>provided</scope>
        </dependency>
    </dependencies>
</project>
```

#### 4.2 创建目录结构

```
junoyi-module-product/
└── src/main/java/cn/junoyi/module/product/
    ├── controller/         # 控制器
    │   └── ProductController.java
    ├── service/
    │   └── impl/           # 服务实现
    │       └── ProductServiceImpl.java
    └── convert/            # 对象转换器
        └── ProductConvert.java
```

#### 4.3 创建 Service 实现

`ProductServiceImpl.java`

```java
package cn.junoyi.module.product.service.impl;

import cn.junoyi.module.product.api.domain.entity.Product;
import cn.junoyi.module.product.api.domain.vo.ProductVO;
import cn.junoyi.module.product.api.mapper.ProductMapper;
import cn.junoyi.module.product.api.service.IProductService;
import cn.junoyi.module.product.convert.ProductConvert;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class ProductServiceImpl extends ServiceImpl<ProductMapper, Product> 
        implements IProductService {

    @Override
    public List<ProductVO> getProductList() {
        List<Product> products = list();
        return ProductConvert.INSTANCE.toVOList(products);
    }

    @Override
    public ProductVO getProductById(Long id) {
        Product product = getById(id);
        return ProductConvert.INSTANCE.toVO(product);
    }

    @Override
    public boolean createProduct(Product product) {
        return save(product);
    }
}
```

#### 4.4 创建对象转换器

`ProductConvert.java`

```java
package cn.junoyi.module.product.convert;

import cn.junoyi.module.product.api.domain.entity.Product;
import cn.junoyi.module.product.api.domain.vo.ProductVO;
import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;
import java.util.List;

@Mapper
public interface ProductConvert {
    
    ProductConvert INSTANCE = Mappers.getMapper(ProductConvert.class);
    
    ProductVO toVO(Product product);
    
    List<ProductVO> toVOList(List<Product> products);
}
```

#### 4.5 创建 Controller

`ProductController.java`

```java
package cn.junoyi.module.product.controller;

import cn.junoyi.module.product.api.domain.entity.Product;
import cn.junoyi.module.product.api.domain.vo.ProductVO;
import cn.junoyi.module.product.api.service.IProductService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/product")
public class ProductController {

    @Autowired
    private IProductService productService;

    @GetMapping("/list")
    public List<ProductVO> list() {
        return productService.getProductList();
    }

    @GetMapping("/{id}")
    public ProductVO getById(@PathVariable Long id) {
        return productService.getProductById(id);
    }

    @PostMapping
    public boolean create(@RequestBody Product product) {
        return productService.createProduct(product);
    }
}
```

---

### 步骤 5: 在父模块中注册实现模块

修改 `junoyi-module/pom.xml`，添加新模块：

```xml
<modules>
    <module>junoyi-module-system</module>
    <module>junoyi-module-product</module>  <!-- 新增 -->
</modules>
```

---

### 步骤 6: 在 dependencies 中注册实现模块版本

修改 `junoyi-dependencies/pom.xml`：

```xml
<dependencyManagement>
    <dependencies>
        <!-- 其他依赖... -->
        
        <!-- 新增商品模块实现 -->
        <dependency>
            <groupId>cn.junoyi</groupId>
            <artifactId>junoyi-module-product</artifactId>
            <version>${revision}</version>
        </dependency>
    </dependencies>
</dependencyManagement>
```

---

### 步骤 7: 在 server 模块中引入新模块

修改 `junoyi-server/pom.xml`，添加依赖：

```xml
<dependencies>
    <!-- 其他依赖... -->
    
    <!-- 新增商品模块 -->
    <dependency>
        <groupId>cn.junoyi</groupId>
        <artifactId>junoyi-module-product</artifactId>
    </dependency>
</dependencies>
```

---

### 步骤 8: 构建并运行

```bash
# 在根目录执行
mvn clean install

# 运行项目
cd junoyi-server
mvn spring-boot:run
```

---

## 二、模块引用关联规则

### 2.1 依赖层次图

```
junoyi-server (启动模块)
    ↓
junoyi-module-xxx (功能实现)
    ↓
junoyi-module-xxx-api (接口定义)
    ↓
junoyi-framework-web (Web封装)
    ↓
junoyi-framework-core (核心封装)
    ↓
junoyi-common (公共模块)
```

### 2.2 引用规则

| 模块类型 | 可以依赖的模块 | 说明 |
|---------|--------------|------|
| **common** | 无 | 最底层，不依赖任何内部模块 |
| **framework-core** | common | 只依赖公共模块 |
| **framework-web** | framework-core, common | 依赖核心框架和公共模块 |
| **module-xxx-api** | common | 只依赖公共模块，定义接口和领域对象 |
| **module-xxx** | module-xxx-api, framework-web, common | 依赖对应API、框架和公共模块 |
| **server** | module-xxx, framework-web | 依赖需要的功能模块和框架 |

### 2.3 禁止的依赖关系

❌ **禁止循环依赖**
```
module-a → module-b → module-a  (错误)
```

❌ **禁止跨层依赖**
```
module-xxx-api → framework-web  (错误，API不应依赖框架)
```

❌ **禁止实现模块互相依赖**
```
module-product → module-system  (错误，应通过API依赖)
```

✅ **正确的模块间依赖**
```
module-product → module-system-api  (正确，依赖API而非实现)
```

---

## 三、模块间调用示例

### 场景：商品模块需要调用用户模块

#### 3.1 在 product 模块的 pom.xml 中添加依赖

```xml
<dependencies>
    <!-- 依赖用户模块的 API -->
    <dependency>
        <groupId>cn.junoyi</groupId>
        <artifactId>junoyi-module-system-api</artifactId>
    </dependency>
</dependencies>
```

#### 3.2 在 Service 中注入并调用

```java
@Service
public class ProductServiceImpl extends ServiceImpl<ProductMapper, Product> 
        implements IProductService {

    @Autowired
    private IUserService userService;  // 注入用户服务

    @Override
    public ProductVO getProductWithUser(Long productId) {
        Product product = getById(productId);
        ProductVO vo = ProductConvert.INSTANCE.toVO(product);
        
        // 调用用户服务获取创建者信息
        UserVO creator = userService.getUserById(product.getCreatorId());
        vo.setCreator(creator);
        
        return vo;
    }
}
```

---

## 四、版本管理最佳实践

### 4.1 新增第三方依赖

**步骤：**

1. 在 `junoyi-dependencies/pom.xml` 中定义版本号：

```xml
<properties>
    <新依赖.version>x.x.x</新依赖.version>
</properties>
```

2. 在 `<dependencyManagement>` 中声明：

```xml
<dependency>
    <groupId>xxx</groupId>
    <artifactId>xxx</artifactId>
    <version>${新依赖.version}</version>
</dependency>
```

3. 在需要的模块中引用（不指定版本）：

```xml
<dependency>
    <groupId>xxx</groupId>
    <artifactId>xxx</artifactId>
</dependency>
```

### 4.2 升级依赖版本

**只需修改 `junoyi-dependencies/pom.xml` 中的版本号即可：**

```xml
<properties>
    <!-- 升级 MyBatis Plus -->
    <mybatis-plus.version>3.5.6</mybatis-plus.version>
</properties>
```

---

## 五、常见开发场景

### 5.1 添加新的 Common 工具类

```
junoyi-common/src/main/java/cn/junoyi/common/utils/
└── StringUtil.java
```

所有模块都可以直接使用，无需额外配置。

### 5.2 添加新的 Framework 功能

例如添加统一返回结果类：

```
junoyi-framework-core/src/main/java/cn/junoyi/framework/core/result/
└── Result.java
```

其他模块通过依赖 `framework-core` 或 `framework-web` 即可使用。

### 5.3 创建子模块的子模块

例如在 common 下创建多个子模块：

```
junoyi-common/
├── junoyi-common-core/      # 核心工具
├── junoyi-common-redis/     # Redis工具
└── junoyi-common-security/  # 安全工具
```

修改 `junoyi-common/pom.xml`：

```xml
<packaging>pom</packaging>
<modules>
    <module>junoyi-common-core</module>
    <module>junoyi-common-redis</module>
    <module>junoyi-common-security</module>
</modules>
```

---

## 六、开发检查清单

创建新模块时，请确保：

- [ ] 在对应的父模块 pom.xml 中添加 `<module>` 声明
- [ ] 在 `junoyi-dependencies/pom.xml` 中添加版本管理
- [ ] 子模块的 `<parent>` 正确指向父模块
- [ ] `<relativePath>` 正确设置为 `../pom.xml`
- [ ] 不要在子模块中硬编码版本号
- [ ] 遵循包名规范：`cn.junoyi.模块名`
- [ ] API 模块只定义接口，不包含实现
- [ ] 实现模块依赖对应的 API 模块

---

## 七、故障排查

### 问题1: 找不到依赖

**原因：** 未在 `junoyi-dependencies` 中声明版本

**解决：** 在 `junoyi-dependencies/pom.xml` 的 `<dependencyManagement>` 中添加

### 问题2: 版本冲突

**原因：** 子模块中硬编码了版本号

**解决：** 移除子模块中的 `<version>` 标签，统一由 dependencies 管理

### 问题3: 循环依赖

**原因：** 模块间存在循环引用

**解决：** 检查依赖关系，通过 API 模块解耦

---

## 八、推荐开发流程

1. **需求分析** → 确定需要创建的模块
2. **创建 API 模块** → 定义接口和领域对象
3. **注册到父模块** → 在 module-api 和 dependencies 中注册
4. **创建实现模块** → 实现业务逻辑
5. **注册到父模块** → 在 module 和 dependencies 中注册
6. **在 server 中引入** → 添加依赖
7. **构建测试** → mvn clean install
8. **运行验证** → 启动项目测试功能

---

**文档更新日期：** 2024-11-23
